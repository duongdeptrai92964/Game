<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GALAGA - Space Shooter</title>


    <!-- Anti-DevTools Protection (Inline) -->
    <script>
        // ANTI-TAMPERMONKEY DETECTION (MUST RUN FIRST!)
        (function () {
            const tm = ['GM_info', 'GM_getValue', 'GM_setValue', 'GM_deleteValue', 'GM_listValues', 'GM_addStyle', 'GM_log', 'GM_openInTab', 'GM_xmlhttpRequest', 'unsafeWindow', 'GM', 'GM_cookie'];
            for (let i of tm) {
                if (window[i] !== undefined || (typeof unsafeWindow !== 'undefined' && unsafeWindow[i])) {
                    alert('‚õî CHEAT SCRIPT DETECTED!\nTamperMonkey/Greasemonkey kh√¥ng ƒë∆∞·ª£c ph√©p.\nGame s·∫Ω kh√¥ng ho·∫°t ƒë·ªông.');
                    window.location.replace('about:blank');
                    throw new Error('Userscript detected');
                }
            }
            if (document.querySelector('script[data-tampermonkey]') || document.querySelector('script[data-greasemonkey]')) {
                window.location.replace('about:blank');
            }
            // Protect critical functions
            const oSI = window.setInterval, oST = window.setTimeout, oRAF = window.requestAnimationFrame;
            Object.defineProperty(window, 'setInterval', { value: oSI, writable: !1, configurable: !1 });
            Object.defineProperty(window, 'setTimeout', { value: oST, writable: !1, configurable: !1 });
            setInterval(() => {
                if (window.setInterval !== oSI || window.setTimeout !== oST || window.requestAnimationFrame !== oRAF) {
                    console.error('üö® FUNCTION OVERRIDE!');
                    window.location.replace('about:blank');
                }
                // Re-check TamperMonkey
                for (let i of tm) {
                    if (window[i] !== undefined) {
                        window.location.replace('about:blank');
                    }
                }
            }, 1000);
        })();

        // Original anti-devtools
        (function () { let t = !1, o = 0; function e() { if (window.eruda) return window.eruda.destroy(), delete window.eruda, !0; if (window.VConsole || window.vConsole) { try { window.vConsole?.destroy?.(), delete window.VConsole, delete window.vConsole } catch { } return !0 } const t = document.querySelectorAll('[class*="eruda"], [id*="eruda"], [class*="vconsole"], [id*="vconsole"]'); return t.length > 0 && (t.forEach(t => t.remove()), !0) } function n() { t || (t = !0, window.location.replace("about:blank")) } function l(t) { return (t.key === "F12" || t.keyCode === 123 || t.ctrlKey && t.shiftKey && (t.key === "I" || t.key === "i" || t.keyCode === 73 || t.key === "J" || t.key === "j" || t.keyCode === 74 || t.key === "C" || t.key === "c" || t.keyCode === 67) || t.ctrlKey && (t.key === "u" || t.key === "U" || t.keyCode === 85 || t.key === "s" || t.key === "S" || t.keyCode === 83) || t.metaKey && t.altKey && (t.key === "i" || t.key === "I" || t.keyCode === 73 || t.key === "j" || t.key === "J" || t.keyCode === 74 || t.key === "c" || t.key === "C" || t.keyCode === 67)) && (t.preventDefault(), t.stopPropagation(), !1) } function r(t) { return t.preventDefault(), t.stopPropagation(), !1 } function i() { const t = 160; (window.outerWidth - window.innerWidth > t || window.outerHeight - window.innerHeight > t) && (o++, o > 2 && n()) } document.addEventListener("keydown", l, !0), document.addEventListener("keyup", l, !0), document.addEventListener("contextmenu", r, !0), document.addEventListener("selectstart", r), document.addEventListener("dragstart", r), document.addEventListener("copy", r), document.addEventListener("cut", r), document.addEventListener("paste", r), window.print = () => !1, setInterval(() => { i(), e() }, 1e3), setInterval(() => { try { ["log", "debug", "info", "warn", "error", "table", "trace", "dir", "dirxml", "group", "groupCollapsed", "groupEnd", "time", "timeEnd", "timeLog", "profile", "profileEnd", "assert", "count", "countReset", "clear"].forEach(t => { console[t] = () => void 0 }) } catch { } }, 500), new MutationObserver(t => { t.forEach(t => { t.addedNodes.forEach(t => { t instanceof HTMLElement && ((t.className?.toString?.() || "").includes("eruda") || (t.className?.toString?.() || "").includes("vconsole") || t.id.includes("eruda") || t.id.includes("vconsole")) && t.remove(), t instanceof HTMLScriptElement && ((t.src || "").includes("eruda") || (t.src || "").includes("vconsole")) && t.remove() }) }) }).observe(document.documentElement, { childList: !0, subtree: !0 }); const c = document.createElement("style"); c.textContent = "*{-webkit-user-select:none!important;-moz-user-select:none!important;-ms-user-select:none!important;user-select:none!important;-webkit-touch-callout:none!important}input,textarea{-webkit-user-select:text!important;-moz-user-select:text!important;-ms-user-select:text!important;user-select:text!important}", document.head.appendChild(c) })();
    </script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            color: #fff;
        }

        #gameCanvas {
            display: block;
            margin: 0 auto;
            background: #000;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        /* Responsive ch·ªâ cho mobile */
        @media (max-width: 768px) {
            #gameCanvas {
                max-width: 100%;
                max-height: 100vh;
                width: 100%;
                height: auto;
            }
        }

        .screen-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }

        .screen-overlay h1 {
            font-size: 64px;
            margin-bottom: 30px;
            color: #ff0;
            text-shadow: 0 0 20px #ff0;
        }

        .screen-overlay button {
            margin-top: 30px;
            padding: 15px 40px;
            font-size: 24px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            background: #f00;
            color: #fff;
            border: none;
            cursor: pointer;
            text-transform: uppercase;
        }

        .screen-overlay button:hover {
            background: #fff;
            color: #f00;
        }

        .hidden {
            display: none !important;
        }

        .controls {
            color: #0ff;
            font-size: 18px;
            margin: 20px 0;
        }

        /* Mobile Joystick - Even Larger */
        .joystick-container {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 180px;
            /* TƒÉng t·ª´ 150px */
            height: 180px;
            display: none;
            z-index: 1000;
            touch-action: none;
            /* Prevent scroll on touch */
        }

        .joystick-base {
            width: 100%;
            height: 100%;
            background: rgba(0, 255, 255, 0.2);
            border: 3px solid #0ff;
            border-radius: 50%;
            position: relative;
        }

        .joystick-stick {
            width: 70px;
            /* TƒÉng t·ª´ 60px */
            height: 70px;
            background: #0ff;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 25px #0ff;
            /* TƒÉng glow */
            transition: transform 0.05s ease-out;
            /* Smooth movement */
        }

        @media (max-width: 768px) {
            .joystick-container {
                display: block;
            }
        }
    </style>
</head>

<body>
    <!-- Start Screen -->
    <div class="screen-overlay" id="startScreen">
        <h1>GALAGA</h1>
        <div class="controls">
            <p>‚Üê ‚Üí ‚Üë ‚Üì: DI CHUY·ªÇN | T·ª∞ ƒê·ªòNG B·∫ÆN | P: T·∫†M D·ª™NG</p>
        </div>
        <button id="startBtn">START</button>
    </div>

    <!-- Game Over Screen -->
    <div class="screen-overlay hidden" id="gameOverScreen">
        <h1 style="color: #f00;">GAME OVER</h1>
        <div style="margin: 20px 0; font-size: 24px; color: #0ff;">
            <p>SCORE: <span id="finalScore">0</span></p>
            <p>STAGE: <span id="finalStage">0</span></p>
        </div>
        <button id="restartBtn">RESTART</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <!-- Mobile Joystick -->
    <div class="joystick-container" id="joystickContainer">
        <div class="joystick-base">
            <div class="joystick-stick" id="joystickStick"></div>
        </div>
    </div>

    <script>
        // Anti-paste protection cho console
        (function () {
            const isDevToolsOpen = () => {
                const threshold = 160;
                return window.outerWidth - window.innerWidth > threshold ||
                    window.outerHeight - window.innerHeight > threshold;
            };

            // Warning message
            const showConsoleWarning = () => {
                console.log('%c‚õî D·ª™NG L·∫†I! ‚õî', 'color: red; font-size: 50px; font-weight: bold;');
                console.log('%c‚ö†Ô∏è C·∫£nh b√°o b·∫£o m·∫≠t', 'color: yellow; font-size: 30px;');
                console.log('%cƒê√¢y l√† t√≠nh nƒÉng d√†nh cho developers. N·∫øu ai ƒë√≥ b·∫£o b·∫°n copy/paste code v√†o ƒë√¢y, ƒë√≥ l√† L·ª™A ƒê·∫¢O!', 'font-size: 16px;');
                console.log('%cD√°n code v√†o ƒë√¢y c√≥ th·ªÉ cho ph√©p k·∫ª x·∫•u ƒë√°nh c·∫Øp t√†i kho·∫£n ho·∫∑c cheat game!', 'color: red; font-size: 14px;');
            };

            // Block paste in console
            const originalLog = console.log;
            let warned = false;

            setInterval(() => {
                if (isDevToolsOpen() && !warned) {
                    showConsoleWarning();
                    warned = true;
                }
            }, 1000);

            // Override console methods to show warning
            ['log', 'warn', 'error', 'info'].forEach(method => {
                const original = console[method];
                console[method] = function (...args) {
                    if (!warned && isDevToolsOpen()) {
                        showConsoleWarning();
                        warned = true;
                    }
                    original.apply(console, args);
                };
            });

            // Anti-debugger detection
            setInterval(() => {
                const start = performance.now();
                debugger;
                const end = performance.now();
                if (end - start > 100) {
                    console.clear();
                    console.error('%c‚ö†Ô∏è Debugger detected!', 'color: red; font-size: 20px;');
                }
            }, 3000);
        })();

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Responsive canvas sizing
        function resizeCanvas() {
            const isMobile = window.innerWidth < 768;
            if (isMobile) {
                // Mobile: full width, maintain aspect ratio
                canvas.width = Math.min(window.innerWidth, 600);
                canvas.height = Math.min(window.innerHeight, 800);
            } else {
                // Desktop: fixed size
                canvas.width = 800;
                canvas.height = 600;
            }
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Game state
        const game = {
            score: 0,
            highScore: 0,
            stage: 1,
            lives: 3,
            isPaused: false,
            isGameOver: false,
            isPlaying: false,
            screenShake: 0,
            bossActive: false,
            currentBoss: null,
            isWaveTransitioning: false // NgƒÉn stage tƒÉng nhi·ªÅu l·∫ßn
        };

        // ========== ADVANCED ANTI-CHEAT SYSTEM ==========
        (function () {
            // Private encrypted storage
            const _secret = Math.random().toString(36).substring(7);
            const _encrypt = (val) => val ^ 0xDEADBEEF;
            const _decrypt = (val) => val ^ 0xDEADBEEF;

            // True player data - HIDDEN in closure
            const _realPlayerData = {
                x: canvas.width / 2,
                y: canvas.height - 60,
                width: 32,
                height: 32,
                speed: _encrypt(4), // Encrypted
                moveLeft: false,
                moveRight: false,
                moveUp: false,
                moveDown: false,
                autoFire: true,
                fireRate: _encrypt(250), // Encrypted
                lastShootTime: 0,
                hasShield: false,
                shieldHits: 0,
                shieldMaxHits: _encrypt(10), // Encrypted
                shieldEndTime: 0,
                hasTripleShot: false,
                tripleShotEndTime: 0
            };

            // Honeypot - fake data ƒë·ªÉ catch cheater
            window._playerData = {
                speed: 999,
                fireRate: 1,
                shieldMaxHits: 999,
                lives: 999,
                invincible: true
            };

            // Public player interface v·ªõi Proxy
            window.player = new Proxy({}, {
                get(target, prop) {
                    // Decrypt khi read
                    if (prop === 'speed') return _decrypt(_realPlayerData.speed);
                    if (prop === 'fireRate') return _decrypt(_realPlayerData.fireRate);
                    if (prop === 'shieldMaxHits') return _decrypt(_realPlayerData.shieldMaxHits);
                    return _realPlayerData[prop];
                },
                set(target, prop, value) {
                    // Allowed props
                    const allowed = ['x', 'y', 'moveLeft', 'moveRight', 'moveUp', 'moveDown',
                        'hasShield', 'shieldHits', 'hasTripleShot', 'shieldEndTime',
                        'tripleShotEndTime', 'lastShootTime'];

                    if (!allowed.includes(prop)) {
                        console.warn('üö® CHEAT DETECTED: Illegal property access');
                        return false;
                    }

                    // Validate ranges
                    if ((prop === 'x' || prop === 'y') && (value < -100 || value > 10000)) {
                        return false;
                    }

                    _realPlayerData[prop] = value;
                    return true;
                },
                has(target, prop) {
                    return prop in _realPlayerData;
                },
                ownKeys(target) {
                    return Object.keys(_realPlayerData);
                },
                getOwnPropertyDescriptor(target, prop) {
                    return {
                        enumerable: true,
                        configurable: true
                    };
                }
            });

            // SUPER FAST integrity check (100ms)
            setInterval(() => {
                // Check encrypted values
                if (_decrypt(_realPlayerData.speed) !== 4) {
                    _realPlayerData.speed = _encrypt(4);
                    console.error('‚ö†Ô∏è TAMPERING DETECTED: Speed reset');
                }
                if (_decrypt(_realPlayerData.fireRate) !== 250) {
                    _realPlayerData.fireRate = _encrypt(250);
                }
                if (_decrypt(_realPlayerData.shieldMaxHits) !== 10) {
                    _realPlayerData.shieldMaxHits = _encrypt(10);
                }

                // Check if someone touched honeypot
                if (window._playerData.speed !== 999 ||
                    window._playerData.fireRate !== 1 ||
                    window._playerData.shieldMaxHits !== 999) {
                    console.error('üö® HONEYPOT TRIGGERED - Cheater detected!');
                    // Reset honeypot
                    window._playerData = {
                        speed: 999,
                        fireRate: 1,
                        shieldMaxHits: 999,
                        lives: 999,
                        invincible: true
                    };
                }
            }, 100); // Check every 100ms!
        })();

        let bullets = [];
        let enemies = [];
        let enemyBullets = [];
        let explosions = [];
        let stars = [];
        let powerUps = [];

        // Load game over sound
        const gameOverSound = new Audio('game-over-38511.mp3');
        gameOverSound.volume = 0.5; // 50% volume

        // Create stars
        for (let i = 0; i < 80; i++) {
            stars.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                speed: Math.random() * 1.5 + 0.3,
                size: Math.random() < 0.5 ? 1 : 2
            });
        }

        // Enemy types (Expanded - More Variety)
        const enemyTypes = [
            { type: 'green', health: 1, points: 50, color1: '#0f0', color2: '#4f4' },        // Xanh l√°
            { type: 'lime', health: 1, points: 60, color1: '#0ff', color2: '#8ff' },         // Xanh l∆° - M·ªõi
            { type: 'blue', health: 2, points: 80, color1: '#00f', color2: '#88f' },         // Xanh d∆∞∆°ng
            { type: 'cyan', health: 2, points: 90, color1: '#0cf', color2: '#6ff' },         // Xanh cyan - M·ªõi
            { type: 'red', health: 2, points: 100, color1: '#f00', color2: '#f88' },         // ƒê·ªè
            { type: 'orange', health: 3, points: 120, color1: '#f80', color2: '#fc8' },      // Cam - M·ªõi
            { type: 'yellow', health: 1, points: 150, color1: '#ff0', color2: '#ff8' },      // V√†ng - 1 hit
            { type: 'purple', health: 2, points: 200, color1: '#f0f', color2: '#f8f' },      // T√≠m - 2 hit
            { type: 'pink', health: 3, points: 250, color1: '#f08', color2: '#f8c' },        // H·ªìng - M·ªõi
            { type: 'white', health: 4, points: 300, color1: '#fff', color2: '#ddd' },       // Tr·∫Øng - M·ªõi, kh√≥ nh·∫•t
            { type: 'kamikaze', health: 1, points: 180, color1: '#a00', color2: '#f00', isKamikaze: true }  // KAMIKAZE - T·ª± s√°t!
        ];

        // Controls
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') player.moveLeft = true;
            if (e.key === 'ArrowRight') player.moveRight = true;
            if (e.key === 'ArrowUp') player.moveUp = true;
            if (e.key === 'ArrowDown') player.moveDown = true;
            if (e.key === 'p' || e.key === 'P') togglePause();
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft') player.moveLeft = false;
            if (e.key === 'ArrowRight') player.moveRight = false;
            if (e.key === 'ArrowUp') player.moveUp = false;
            if (e.key === 'ArrowDown') player.moveDown = false;
        });

        // Mobile Joystick Controls
        const joystickContainer = document.getElementById('joystickContainer');
        const joystickStick = document.getElementById('joystickStick');
        let joystickActive = false;
        let joystickCenter = { x: 0, y: 0 };

        function handleJoystickStart(e) {
            e.preventDefault();
            joystickActive = true;
            const rect = joystickContainer.getBoundingClientRect();
            joystickCenter = {
                x: rect.left + rect.width / 2,
                y: rect.top + rect.height / 2
            };
        }

        function handleJoystickMove(e) {
            if (!joystickActive) return;
            e.preventDefault();

            const touch = e.touches ? e.touches[0] : e;
            const deltaX = touch.clientX - joystickCenter.x;
            const deltaY = touch.clientY - joystickCenter.y;

            // Gi·ªõi h·∫°n stick trong v√≤ng tr√≤n
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const maxDistance = 60;  // TƒÉng t·ª´ 50 ƒë·ªÉ ph√π h·ª£p joystick 180px
            const limitedDist = Math.min(distance, maxDistance);
            const angle = Math.atan2(deltaY, deltaX);

            const stickX = Math.cos(angle) * limitedDist;
            const stickY = Math.sin(angle) * limitedDist;

            joystickStick.style.transform = `translate(calc(-50% + ${stickX}px), calc(-50% + ${stickY}px))`;

            // C·∫≠p nh·∫≠t player movement - ƒêI·ªÄU CH·ªàNH ƒê·ªò NH·∫†Y
            const threshold = 8;  // TƒÉng threshold ƒë·ªÉ gi·∫£m ƒë·ªô nh·∫°y (DPI th·∫•p h∆°n)
            player.moveLeft = stickX < -threshold;
            player.moveRight = stickX > threshold;
            player.moveUp = stickY < -threshold;
            player.moveDown = stickY > threshold;
        }

        function handleJoystickEnd(e) {
            e.preventDefault();
            joystickActive = false;
            joystickStick.style.transform = 'translate(-50%, -50%)';
            player.moveLeft = false;
            player.moveRight = false;
            player.moveUp = false;
            player.moveDown = false;
        }

        // Touch events
        joystickContainer.addEventListener('touchstart', handleJoystickStart);
        joystickContainer.addEventListener('touchmove', handleJoystickMove);
        joystickContainer.addEventListener('touchend', handleJoystickEnd);
        joystickContainer.addEventListener('touchcancel', handleJoystickEnd);

        // Mouse events (for testing on desktop)
        joystickContainer.addEventListener('mousedown', handleJoystickStart);
        document.addEventListener('mousemove', handleJoystickMove);
        document.addEventListener('mouseup', handleJoystickEnd);

        // Canvas click handler for pause menu buttons
        canvas.addEventListener('click', (e) => {
            if (!game.isPaused) return;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            const buttonWidth = 200;
            const buttonHeight = 50;
            const centerX = canvas.width / 2;
            const buttonY1 = canvas.height / 2 + 20;
            const buttonY2 = canvas.height / 2 + 90;

            // Check Continue button
            if (x >= centerX - buttonWidth / 2 && x <= centerX + buttonWidth / 2 &&
                y >= buttonY1 && y <= buttonY1 + buttonHeight) {
                togglePause();
            }

            // Check Home button
            if (x >= centerX - buttonWidth / 2 - 110 && x <= centerX - buttonWidth / 2 - 10 &&
                y >= buttonY2 && y <= buttonY2 + buttonHeight) {
                // Go to home
                game.isPaused = false;
                game.isPlaying = false;
                document.getElementById('gameOverScreen').classList.add('hidden');
                document.getElementById('startScreen').classList.remove('hidden');
            }

            // Check Restart button
            if (x >= centerX - buttonWidth / 2 + 10 && x <= centerX - buttonWidth / 2 + 110 &&
                y >= buttonY2 && y <= buttonY2 + buttonHeight) {
                // Restart game
                game.isPaused = false;
                startGame();
            }
        });

        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('restartBtn').addEventListener('click', () => {
            document.getElementById('gameOverScreen').classList.add('hidden');
            startGame();
        });

        function startGame() {
            game.score = 0;
            game.stage = 1;
            game.lives = 3;
            game.isPaused = false;
            game.isGameOver = false;
            game.isPlaying = true;

            player.x = canvas.width / 2;
            player.y = canvas.height - 60;
            player.hasShield = false;
            player.shieldHits = 0;
            player.hasTripleShot = false;

            bullets = [];
            enemies = [];
            enemyBullets = [];
            explosions = [];
            powerUps = []; // Clear power-ups

            document.getElementById('startScreen').classList.add('hidden');
            spawnWave();
            gameLoop();
        }

        function spawnWave() {
            enemies = [];

            // Boss wave m·ªói 10 stage
            if (game.stage % 10 === 0) {
                console.log(`üî• BOSS WAVE ${game.stage}!`);

                const bossLevel = Math.floor(game.stage / 10); // Boss level (1, 2, 3...)

                // Boss tƒÉng size theo level
                const bossSize = 64 + bossLevel * 16; // Wave 10: 80, Wave 20: 96, Wave 30: 112

                // Boss m√°u: Wave 10=100, Wave 20=150, Wave 30=200, Wave 40=250...
                const bossHealth = 50 + bossLevel * 50;
                const bossPoints = 1000 * bossLevel;

                const boss = {
                    x: canvas.width / 2,
                    y: 100,
                    startX: canvas.width / 2,
                    startY: 100,
                    width: bossSize,
                    height: bossSize,
                    angle: 0,
                    movePhase: 'boss',
                    isBoss: true,
                    bossLevel: bossLevel,
                    emoji: 'üëæ',
                    health: bossHealth,
                    maxHealth: bossHealth,
                    speed: 0.8,
                    points: bossPoints,
                    color1: '#f0f',
                    color2: '#f8f',
                    shootTimer: 0,
                    // Boss abilities
                    summonTimer: 0,
                    throwTimer: 0,
                    lastSummonTime: 0,
                    lastThrowTime: 0
                };

                enemies.push(boss);

                // Trigger screen shake v√† set boss active
                game.screenShake = 30;
                game.bossActive = true;
                game.currentBoss = boss;

                console.log(`üëæ Boss Lv.${bossLevel}: ${bossHealth} HP, ${bossPoints} points, Size: ${bossSize}`);
                return;
            }

            // Normal waves
            game.bossActive = false; // T·∫Øt boss UI cho wave th∆∞·ªùng
            game.currentBoss = null;

            const totalEnemies = Math.min(6 + (game.stage - 1) * 3, 40);  // CAP T·∫†I 40

            // ƒê∆°n gi·∫£n h√≥a: x·∫øp h√†ng ngang v·ªõi t·ªëi ƒëa 10 c·ªôt
            const cols = Math.min(totalEnemies, 10);
            const rows = Math.ceil(totalEnemies / cols);

            const spacing = 50;
            const startX = (canvas.width - (cols * spacing)) / 2 + spacing / 2;
            const startY = 60;

            console.log(`Stage ${game.stage}: Spawning ${totalEnemies} enemies (${rows} rows x ${cols} cols)`);

            let enemyCount = 0;
            for (let row = 0; row < rows && enemyCount < totalEnemies; row++) {
                for (let col = 0; col < cols && enemyCount < totalEnemies; col++) {
                    let typeIndex;
                    if (row === 0) typeIndex = 3; // Yellow (top row)
                    else if (row <= 2) typeIndex = 2; // Red
                    else if (row <= 4) typeIndex = 1; // Blue
                    else typeIndex = 0; // Green

                    // TƒÉng ƒë·ªô kh√≥ theo stage
                    const type = enemyTypes[Math.min(typeIndex + Math.floor(game.stage / 3), enemyTypes.length - 1)];

                    enemies.push({
                        x: startX + col * spacing,
                        y: startY + row * spacing,
                        startX: startX + col * spacing,
                        startY: startY + row * spacing,
                        width: 32,
                        height: 32,
                        angle: (col + row) * 0.5,
                        movePhase: 'idle',
                        ...type,
                        maxHealth: type.health,
                        shootTimer: Math.random() * 400 // TƒÉng delay b·∫Øn (ch·∫≠m h∆°n)
                    });

                    enemyCount++;
                }
            }

            console.log(`Actually spawned: ${enemies.length} enemies`);
        }

        function shootBullet() {
            if (player.hasTripleShot) {
                // ƒê·∫°n gi·ªØa - TO H∆†N V√Ä M·∫†NH H∆†N
                bullets.push({
                    x: player.x,
                    y: player.y - 16,
                    width: 6,  // To g·∫•p ƒë√¥i
                    height: 16, // D√†i h∆°n
                    speed: 10,
                    damage: 2  // Damage g·∫•p ƒë√¥i
                });
                // ƒê·∫°n tr√°i - B·∫ÆN TH·∫≤NG
                bullets.push({
                    x: player.x - 15,
                    y: player.y - 10,
                    width: 3,
                    height: 12,
                    speed: 10,
                    damage: 1
                });
                // ƒê·∫°n ph·∫£i - B·∫ÆN TH·∫≤NG
                bullets.push({
                    x: player.x + 15,
                    y: player.y - 10,
                    width: 3,
                    height: 12,
                    speed: 10,
                    damage: 1
                });
            } else {
                // B·∫Øn 1 ƒë∆∞·ªùng b√¨nh th∆∞·ªùng
                bullets.push({
                    x: player.x,
                    y: player.y - 16,
                    width: 3,
                    height: 12,
                    speed: 10,
                    damage: 1
                });
            }
        }

        function updatePlayer() {
            if (player.moveLeft && player.x > 20) {
                player.x -= player.speed;
            }
            if (player.moveRight && player.x < canvas.width - 20) {
                player.x += player.speed;
            }
            if (player.moveUp && player.y > canvas.height / 2) { // Ch·ªâ l√™n ƒë·∫øn gi·ªØa m√†n h√¨nh
                player.y -= player.speed;
            }
            if (player.moveDown && player.y < canvas.height - 40) {
                player.y += player.speed;
            }

            // Auto-fire
            const now = Date.now();
            if (player.autoFire && now - player.lastShootTime > player.fireRate) {
                shootBullet();
                player.lastShootTime = now;
            }

            // Check shield timeout
            if (player.hasShield && now > player.shieldEndTime) {
                player.hasShield = false;
            }

            // Check triple shot timeout
            if (player.hasTripleShot && now > player.tripleShotEndTime) {
                player.hasTripleShot = false;
            }
        }

        function updatePowerUps() {
            powerUps = powerUps.filter(p => {
                p.y += p.speed;
                return p.y < canvas.height + 20;
            });
        }

        function updateBullets() {
            bullets = bullets.filter(b => {
                b.y -= b.speed;
                return b.y > -20;
            });
        }

        function updateEnemies() {
            enemies.forEach(enemy => {
                // KAMIKAZE - Lao v√†o player v√† t·ª± n·ªï!
                if (enemy.isKamikaze) {
                    // Check n·∫øu ƒëang trong warning phase (nh·∫•p nh√°y)
                    if (enemy.exploding) {
                        enemy.explodeTimer = (enemy.explodeTimer || 0) + 1;

                        // Sau 60 frames (1 gi√¢y) ‚Üí EXPLODE!
                        if (enemy.explodeTimer >= 60) {
                            // Ki·ªÉm tra player c√≥ trong blast radius kh√¥ng
                            const dx = player.x - enemy.x;
                            const dy = player.y - enemy.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);

                            if (distance < 80) { // Explosion radius
                                // Player b·ªã damage!
                                if (player.hasShield && player.shieldHits < player.shieldMaxHits) {
                                    player.shieldHits++;
                                    if (player.shieldHits >= player.shieldMaxHits) {
                                        player.hasShield = false;
                                    }
                                } else {
                                    playerHit();
                                }
                            }

                            // T·∫°o explosion visual
                            createExplosion(enemy.x, enemy.y, '#f00');
                            createExplosion(enemy.x, enemy.y, '#ff0');

                            // Hi·ªÉn th·ªã blast zone
                            explosions.push({
                                x: enemy.x,
                                y: enemy.y,
                                isBlastZone: true,
                                radius: 80,
                                life: 30, // Hi·ªÉn th·ªã 0.5s
                                color: '#f00'
                            });

                            // Mark ƒë·ªÉ x√≥a
                            enemy.health = 0;
                        }
                        return; // ƒê·ª©ng y√™n khi exploding
                    }

                    // T√≠nh h∆∞·ªõng ƒë·∫øn player
                    const dx = player.x - enemy.x;
                    const dy = player.y - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    // N·∫øu ƒë·∫øn g·∫ßn player ‚Üí b·∫Øt ƒë·∫ßu warning (ho·∫∑c n·ªï ngay n·∫øu b·ªã n√©m)
                    if (distance < 100) {
                        if (enemy.isThrownKamikaze) {
                            // N·ªî NGAY - kh√¥ng c√≥ warning!
                            enemy.exploding = true;
                            enemy.explodeTimer = 60; // Set max ƒë·ªÉ n·ªï ngay
                        } else {
                            // Kamikaze th∆∞·ªùng - warning 1s
                            enemy.exploding = true;
                            enemy.explodeTimer = 0;
                        }
                        return;
                    }

                    // Lao v·ªÅ ph√≠a player
                    const speed = 3;
                    enemy.x += (dx / distance) * speed;
                    enemy.y += (dy / distance) * speed;

                    return;
                }

                // Boss di chuy·ªÉn v√† chi√™u th·ª©c ƒë·∫∑c bi·ªát
                if (enemy.isBoss) {
                    enemy.angle += 0.03;
                    enemy.x = enemy.startX + Math.sin(enemy.angle) * 150;

                    // Boss b·∫Øn nhanh v√† nhi·ªÅu vi√™n
                    enemy.shootTimer++;
                    if (enemy.shootTimer > 50) {
                        enemy.shootTimer = 0;
                        // B·∫Øn 3 vi√™n c√πng l√∫c
                        for (let i = -1; i <= 1; i++) {
                            enemyBullets.push({
                                x: enemy.x + i * 25,
                                y: enemy.y + 32,
                                width: 4,
                                height: 12,
                                speed: 5,
                                color: '#f0f'
                            });
                        }
                    }

                    // ABILITY 1: Tri·ªáu h·ªìi minions (m·ªói 8 gi√¢y)
                    enemy.summonTimer++;
                    if (enemy.summonTimer > 480 && enemies.length < 10) { // Gi·ªõi h·∫°n 10 enemies
                        enemy.summonTimer = 0;

                        // Tri·ªáu h·ªìi 3 con qu√°i nh·ªè
                        for (let i = 0; i < 3; i++) {
                            const minionType = enemyTypes[Math.floor(Math.random() * 5)]; // Random 5 lo·∫°i y·∫øu
                            enemies.push({
                                x: enemy.x + (i - 1) * 50,
                                y: enemy.y + 50,
                                startX: enemy.x + (i - 1) * 50,
                                startY: enemy.y + 50,
                                width: 32,
                                height: 32,
                                angle: Math.random() * Math.PI * 2,
                                movePhase: 'idle',
                                ...minionType,
                                maxHealth: minionType.health,
                                shootTimer: Math.random() * 300
                            });
                        }

                        // Visual cue
                        createExplosion(enemy.x, enemy.y, '#f0f');
                    }

                    // ABILITY 2: N√©m kamikaze v√†o player (m·ªói 10 gi√¢y)
                    enemy.throwTimer++;
                    if (enemy.throwTimer > 600) {
                        enemy.throwTimer = 0;

                        // T·∫°o kamikaze b·ªã n√©m
                        enemies.push({
                            x: enemy.x,
                            y: enemy.y + 30,
                            startX: enemy.x,
                            startY: enemy.y + 30,
                            width: 32,
                            height: 32,
                            angle: 0,
                            movePhase: 'idle',
                            type: 'kamikaze',
                            isKamikaze: true,
                            isThrownKamikaze: true, // ƒê·∫∑c bi·ªát - n·ªï ngay!
                            health: 1,
                            maxHealth: 1,
                            points: 180,
                            color1: '#a00',
                            color2: '#f00',
                            shootTimer: 0
                        });

                        // Visual cue
                        createExplosion(enemy.x, enemy.y, '#f00');
                    }

                    return;
                }

                // Normal enemies
                enemy.angle += 0.02;
                enemy.x = enemy.startX + Math.sin(enemy.angle) * 30;
                enemy.y = enemy.startY + Math.cos(enemy.angle * 0.5) * 10;

                // Enemy shooting - VARIED BY TYPE
                enemy.shootTimer++;

                // X√°c ƒë·ªãnh t·ªëc ƒë·ªô b·∫Øn d·ª±a tr√™n lo·∫°i qu√°i
                let shootInterval = 300;
                let bulletSpeed = 4;
                let bulletCount = 1;

                if (enemy.type === 'white' || enemy.type === 'pink') {
                    // Qu√°i m·∫°nh nh·∫•t - b·∫Øn nhanh, 2 vi√™n, ƒë·∫°n nhanh
                    shootInterval = 180;
                    bulletSpeed = 5.5;
                    bulletCount = 2;
                } else if (enemy.type === 'orange' || enemy.type === 'purple') {
                    // Qu√°i m·∫°nh - b·∫Øn nhanh h∆°n
                    shootInterval = 220;
                    bulletSpeed = 5;
                } else if (enemy.type === 'yellow') {
                    // Yellow nhanh
                    shootInterval = 240;
                    bulletSpeed = 4.5;
                }

                if (enemy.shootTimer > shootInterval + Math.random() * 150) {
                    enemy.shootTimer = 0;

                    // B·∫Øn nhi·ªÅu vi√™n n·∫øu l√† qu√°i m·∫°nh
                    if (bulletCount === 2) {
                        enemyBullets.push({
                            x: enemy.x - 10,
                            y: enemy.y + 16,
                            width: 3,
                            height: 10,
                            speed: bulletSpeed,
                            color: enemy.color1
                        });
                        enemyBullets.push({
                            x: enemy.x + 10,
                            y: enemy.y + 16,
                            width: 3,
                            height: 10,
                            speed: bulletSpeed,
                            color: enemy.color1
                        });
                    } else {
                        enemyBullets.push({
                            x: enemy.x,
                            y: enemy.y + 16,
                            width: 3,
                            height: 10,
                            speed: bulletSpeed,
                            color: enemy.color1
                        });
                    }
                }
            });
        }

        function updateEnemyBullets() {
            enemyBullets = enemyBullets.filter(b => {
                b.y += b.speed;
                return b.y < canvas.height + 20;
            });
        }

        function checkCollisions() {
            // Bullet vs Enemy
            bullets.forEach((bullet, bIdx) => {
                enemies.forEach((enemy, eIdx) => {
                    if (collision(bullet, enemy)) {
                        const bulletDamage = bullet.damage || 1;
                        enemy.health -= bulletDamage;
                        bullets.splice(bIdx, 1);

                        if (enemy.health <= 0) {
                            game.score += enemy.points;
                            createExplosion(enemy.x, enemy.y, enemy.color1);

                            // 5% chance drop power-up
                            if (Math.random() < 0.05) {
                                const powerUpType = Math.random() < 0.5 ? 'shield' : 'tripleshot';
                                powerUps.push({
                                    x: enemy.x,
                                    y: enemy.y,
                                    type: powerUpType,
                                    width: 20,
                                    height: 20,
                                    speed: 2
                                });
                            }

                            enemies.splice(eIdx, 1);

                            // N·∫øu gi·∫øt boss, t·∫Øt boss UI
                            if (enemy.isBoss) {
                                game.bossActive = false;
                                game.currentBoss = null;
                                game.screenShake = 20;
                            }
                        }
                    }
                });
            });

            // Enemy bullet vs Player
            enemyBullets.forEach((bullet, idx) => {
                if (collision(bullet, player)) {
                    enemyBullets.splice(idx, 1);

                    // Check shield
                    if (player.hasShield && player.shieldHits < player.shieldMaxHits) {
                        player.shieldHits++;
                        createExplosion(player.x, player.y, '#0ff');
                        if (player.shieldHits >= player.shieldMaxHits) {
                            player.hasShield = false;
                        }
                    } else {
                        playerHit();
                    }
                }
            });

            // Power-up vs Player
            powerUps.forEach((powerUp, idx) => {
                if (collision(powerUp, player)) {
                    powerUps.splice(idx, 1);

                    if (powerUp.type === 'shield') {
                        player.hasShield = true;
                        player.shieldHits = 0;
                        player.shieldEndTime = Date.now() + 10000; // 10s
                    } else if (powerUp.type === 'tripleshot') {
                        player.hasTripleShot = true;
                        player.tripleShotEndTime = Date.now() + 10000; // 10s
                    }

                    createExplosion(powerUp.x, powerUp.y, '#ff0');
                }
            });

            // Check wave complete
            if (enemies.length === 0 && game.isPlaying && !game.isWaveTransitioning) {
                game.isWaveTransitioning = true;
                game.stage++;
                setTimeout(() => {
                    spawnWave();
                    game.isWaveTransitioning = false;
                }, 2000);
            }
        }

        function collision(obj1, obj2) {
            return obj1.x < obj2.x + obj2.width &&
                obj1.x + obj1.width > obj2.x &&
                obj1.y < obj2.y + obj2.height &&
                obj1.y + obj1.height > obj2.y;
        }

        function playerHit() {
            game.lives--;
            createExplosion(player.x, player.y, '#0ff');

            if (game.lives <= 0) {
                gameOver();
            }
        }

        function createExplosion(x, y, color) {
            for (let i = 0; i < 8; i++) {
                explosions.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    life: 30,
                    color: color
                });
            }
        }

        function updateExplosions() {
            explosions = explosions.filter(exp => {
                exp.x += exp.vx;
                exp.y += exp.vy;
                exp.life--;
                return exp.life > 0;
            });
        }

        function togglePause() {
            if (!game.isPlaying) return;
            game.isPaused = !game.isPaused;
        }

        // Draw player spaceship (Pixel art sleek design)
        function drawPlayer(x, y) {
            const p = 2; // pixel size
            ctx.save();
            ctx.translate(Math.floor(x), Math.floor(y));

            // Main body - Sleek silver/white
            ctx.fillStyle = '#ddd';
            ctx.fillRect(-2 * p, -8 * p, 4 * p, 12 * p);

            // Cockpit - Red/Orange glass
            ctx.fillStyle = '#f44';
            ctx.fillRect(-2 * p, -9 * p, 4 * p, 2 * p);
            ctx.fillStyle = '#f88';
            ctx.fillRect(-p, -9 * p, 2 * p, p);

            // Wings - Cyan/Aqua
            ctx.fillStyle = '#0ff';
            ctx.fillRect(-7 * p, -2 * p, 14 * p, 4 * p);
            ctx.fillRect(-8 * p, 0, 16 * p, 2 * p);

            // Wing tips - Yellow accent
            ctx.fillStyle = '#ff0';
            ctx.fillRect(-9 * p, p, 2 * p, p);
            ctx.fillRect(7 * p, p, 2 * p, p);

            // Engine glow (animated)
            const glowIntensity = 0.5 + Math.sin(Date.now() / 80) * 0.5;
            ctx.fillStyle = `rgba(255, 100, 0, ${glowIntensity})`;
            ctx.shadowBlur = 8;
            ctx.shadowColor = '#ff6600';
            ctx.fillRect(-3 * p, 4 * p, 2 * p, 2 * p);
            ctx.fillRect(p, 4 * p, 2 * p, 2 * p);

            ctx.restore();
        }

        function gameOver() {
            game.isGameOver = true;
            game.isPlaying = false;
            if (game.score > game.highScore) game.highScore = game.score;

            // Play game over sound
            gameOverSound.currentTime = 0; // Reset to start
            gameOverSound.play().catch(e => console.log('Audio play failed:', e));

            document.getElementById('finalScore').textContent = game.score;
            document.getElementById('finalStage').textContent = game.stage;
            document.getElementById('gameOverScreen').classList.remove('hidden');
        }

        function drawEnemy(enemy) {
            const p = enemy.isBoss ? (3 + (enemy.bossLevel || 1)) : 2; // Boss c√†ng cao c√†ng to
            ctx.save();
            ctx.translate(Math.floor(enemy.x), Math.floor(enemy.y));

            const c1 = enemy.color1;
            const c2 = enemy.color2;

            // Boss design kh√°c bi·ªát
            if (enemy.isBoss) {
                // Boss l·ªõn v√† ƒë√°ng s·ª£ h∆°n
                ctx.fillStyle = c1;
                // Head
                ctx.fillRect(-4 * p, -6 * p, 8 * p, 6 * p);

                // Eyes
                ctx.fillStyle = '#f00';
                ctx.fillRect(-3 * p, -4 * p, 2 * p, 2 * p);
                ctx.fillRect(p, -4 * p, 2 * p, 2 * p);

                // Body
                ctx.fillStyle = c2;
                ctx.fillRect(-5 * p, 0, 10 * p, 4 * p);

                // Arms
                ctx.fillStyle = c1;
                ctx.fillRect(-7 * p, p, 2 * p, 3 * p);
                ctx.fillRect(5 * p, p, 2 * p, 3 * p);

                // Legs
                ctx.fillRect(-4 * p, 4 * p, 2 * p, 2 * p);
                ctx.fillRect(2 * p, 4 * p, 2 * p, 2 * p);

                // Health bar (always show for boss)
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#f00';
                ctx.fillRect(-30, -30, 60, 4);
                ctx.fillStyle = '#0f0';
                ctx.fillRect(-30, -30, 60 * (enemy.health / enemy.maxHealth), 4);

                // Health text
                ctx.font = 'bold 12px Courier';
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.fillText(`${enemy.health}/${enemy.maxHealth}`, 0, -36);

                ctx.restore();
                return;
            }

            // KAMIKAZE - V·∫Ω v·ªõi nh·∫•p nh√°y khi exploding
            if (enemy.isKamikaze) {
                // Nh·∫•p nh√°y n·∫øu ƒëang exploding
                if (enemy.exploding) {
                    const flickerSpeed = 100; // Nh·∫•p nh√°y nhanh
                    const flicker = Math.floor(Date.now() / flickerSpeed) % 2;
                    if (flicker === 0) {
                        ctx.globalAlpha = 0.3; // M·ªù ƒëi
                    }

                    // V·∫Ω warning circle
                    ctx.strokeStyle = '#f00';
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#f00';
                    ctx.beginPath();
                    ctx.arc(0, 0, 40, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Body - H√¨nh tam gi√°c ƒë·ªè (nh∆∞ rocket)
                ctx.fillStyle = c1;
                ctx.beginPath();
                ctx.moveTo(0, -6 * p);  // Top
                ctx.lineTo(-3 * p, 4 * p); // Bottom left
                ctx.lineTo(3 * p, 4 * p);  // Bottom right
                ctx.closePath();
                ctx.fill();

                // Flame effect ·ªü ƒëu√¥i
                const flameFlicker = Math.sin(Date.now() / 50);
                ctx.fillStyle = `rgba(255, ${100 + flameFlicker * 50}, 0, 0.8)`;
                ctx.fillRect(-2 * p, 4 * p, 4 * p, 3 * p);

                ctx.globalAlpha = 1; // Reset alpha
                ctx.restore();
                return;
            }

            // Normal enemy (Butterfly/insect shape - Galaga style)
            // Body
            ctx.fillStyle = c1;
            ctx.fillRect(-p, -4 * p, 2 * p, 8 * p);

            // Wings
            ctx.fillStyle = c2;
            // Left wing
            ctx.fillRect(-5 * p, -3 * p, 3 * p, 2 * p);
            ctx.fillRect(-6 * p, -p, 4 * p, 2 * p);
            ctx.fillRect(-5 * p, p, 3 * p, 2 * p);

            // Right wing
            ctx.fillRect(2 * p, -3 * p, 3 * p, 2 * p);
            ctx.fillRect(2 * p, -p, 4 * p, 2 * p);
            ctx.fillRect(2 * p, p, 3 * p, 2 * p);

            // Antennae
            ctx.fillStyle = c1;
            ctx.fillRect(-2 * p, -6 * p, p, 2 * p);
            ctx.fillRect(p, -6 * p, p, 2 * p);

            // Eyes
            ctx.fillStyle = '#fff';
            ctx.fillRect(-2 * p, -3 * p, p, p);
            ctx.fillRect(p, -3 * p, p, p);

            ctx.restore();
        }

        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Screen shake effect
            ctx.save();
            if (game.screenShake > 0) {
                const shakeX = (Math.random() - 0.5) * game.screenShake;
                const shakeY = (Math.random() - 0.5) * game.screenShake;
                ctx.translate(shakeX, shakeY);
                game.screenShake--; // Gi·∫£m d·∫ßn shake
            }

            // Stars
            stars.forEach(star => {
                star.y += star.speed;
                if (star.y > canvas.height) {
                    star.y = 0;
                    star.x = Math.random() * canvas.width;
                }
                ctx.fillStyle = star.size === 2 ? '#fff' : '#888';
                ctx.fillRect(Math.floor(star.x), Math.floor(star.y), star.size, star.size);
            });

            // UI
            ctx.font = 'bold 20px Courier';
            ctx.fillStyle = '#f00';
            ctx.textAlign = 'left';
            ctx.fillText('1UP', 30, 30);
            ctx.fillStyle = '#fff';
            ctx.fillText(String(game.score).padStart(6, '0'), 30, 50);

            ctx.fillStyle = '#f00';
            ctx.textAlign = 'center';
            ctx.fillText('HI-SCORE', canvas.width / 2, 30);
            ctx.fillStyle = '#0ff';
            ctx.fillText(String(game.highScore).padStart(6, '0'), canvas.width / 2, 50);

            ctx.fillStyle = '#f00';
            ctx.textAlign = 'right';
            ctx.fillText('STAGE', canvas.width - 70, 30);
            ctx.fillStyle = '#fff';
            ctx.fillText(game.stage, canvas.width - 30, 50);

            // Lives
            for (let i = 0; i < game.lives; i++) {
                drawPlayer(30 + i * 40, canvas.height - 25);
            }

            // Player
            drawPlayer(player.x, player.y);

            // Shield circle effect
            if (player.hasShield) {
                ctx.save();
                ctx.strokeStyle = '#0ff';
                ctx.lineWidth = 3;
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#0ff';

                // Animated pulsing effect
                const pulseSize = 3 + Math.sin(Date.now() / 100) * 2;
                ctx.lineWidth = pulseSize;

                ctx.beginPath();
                ctx.arc(Math.floor(player.x), Math.floor(player.y), 30, 0, Math.PI * 2);
                ctx.stroke();

                // Shield hits remaining text
                ctx.font = 'bold 12px Courier';
                ctx.fillStyle = '#0ff';
                ctx.textAlign = 'center';
                ctx.shadowBlur = 5;
                ctx.fillText(`üõ°Ô∏è${player.shieldMaxHits - player.shieldHits}`, player.x, player.y - 35);

                ctx.restore();
            }

            // Triple shot indicator
            if (player.hasTripleShot) {
                ctx.save();
                ctx.font = 'bold 12px Courier';
                ctx.fillStyle = '#ff0';
                ctx.textAlign = 'center';
                ctx.shadowBlur = 5;
                ctx.shadowColor = '#ff0';
                ctx.fillText('‚ö°3X', player.x, player.y + 40);
                ctx.restore();
            }

            // Bullets (v·ªõi k√≠ch th∆∞·ªõc kh√°c nhau)
            ctx.fillStyle = '#fff';
            bullets.forEach(b => {
                const bulletWidth = b.width || 3;
                const bulletHeight = b.height || 12;
                ctx.fillRect(Math.floor(b.x - bulletWidth / 2), Math.floor(b.y), bulletWidth, bulletHeight);
            });

            // Enemies
            enemies.forEach(drawEnemy);

            // Enemy bullets (colored by enemy type)
            enemyBullets.forEach(b => {
                ctx.fillStyle = b.color || '#f0f'; // M√†u theo lo·∫°i qu√°i
                ctx.fillRect(Math.floor(b.x - 1), Math.floor(b.y), 3, 10);
            });

            // Explosions & Blast Zones
            explosions.forEach(exp => {
                if (exp.isBlastZone) {
                    // V·∫Ω blast zone circle
                    ctx.save();
                    ctx.strokeStyle = exp.color;
                    ctx.lineWidth = 4;
                    ctx.globalAlpha = exp.life / 30;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = exp.color;
                    ctx.beginPath();
                    ctx.arc(Math.floor(exp.x), Math.floor(exp.y), exp.radius, 0, Math.PI * 2);
                    ctx.stroke();

                    // Fill semi-transparent
                    ctx.fillStyle = exp.color;
                    ctx.globalAlpha = (exp.life / 30) * 0.2;
                    ctx.fill();
                    ctx.restore();
                } else {
                    // Normal explosion particles
                    ctx.fillStyle = exp.color;
                    ctx.globalAlpha = exp.life / 30;
                    ctx.fillRect(Math.floor(exp.x - 2), Math.floor(exp.y - 2), 4, 4);
                    ctx.globalAlpha = 1;
                }
            });

            // Power-ups
            powerUps.forEach(p => {
                ctx.save();
                ctx.translate(Math.floor(p.x), Math.floor(p.y));
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';

                if (p.type === 'shield') {
                    ctx.fillStyle = '#0ff';
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#0ff';
                    ctx.fillText('üõ°Ô∏è', 0, 0);
                } else if (p.type === 'tripleshot') {
                    ctx.fillStyle = '#ff0';
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#ff0';
                    ctx.fillText('‚ö°', 0, 0);
                }
                ctx.restore();
            });

            // Pause menu
            if (game.isPaused) {
                // Overlay
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Title
                ctx.font = 'bold 48px Courier';
                ctx.fillStyle = '#ff0';
                ctx.textAlign = 'center';
                ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2 - 80);

                // Buttons
                const buttonWidth = 200;
                const buttonHeight = 50;
                const centerX = canvas.width / 2;
                const buttonY1 = canvas.height / 2 + 20;
                const buttonY2 = canvas.height / 2 + 90;

                // Button 1: Continue (P to resume)
                ctx.fillStyle = '#333';
                ctx.fillRect(centerX - buttonWidth / 2, buttonY1, buttonWidth, buttonHeight);
                ctx.strokeStyle = '#0ff';
                ctx.lineWidth = 2;
                ctx.strokeRect(centerX - buttonWidth / 2, buttonY1, buttonWidth, buttonHeight);
                ctx.font = '20px Courier';
                ctx.fillStyle = '#fff';
                ctx.fillText('Ti·∫øp t·ª•c (P)', centerX, buttonY1 + 32);

                // Button 2: Home
                ctx.fillStyle = '#333';
                ctx.fillRect(centerX - buttonWidth / 2 - 110, buttonY2, 100, buttonHeight);
                ctx.strokeStyle = '#f00';
                ctx.lineWidth = 2;
                ctx.strokeRect(centerX - buttonWidth / 2 - 110, buttonY2, 100, buttonHeight);
                ctx.fillStyle = '#fff';
                ctx.fillText('Trang ch·ªß', centerX - buttonWidth / 2 - 60, buttonY2 + 32);

                // Button 3: Restart
                ctx.fillStyle = '#333';
                ctx.fillRect(centerX - buttonWidth / 2 + 10, buttonY2, 100, buttonHeight);
                ctx.strokeStyle = '#0f0';
                ctx.lineWidth = 2;
                ctx.strokeRect(centerX - buttonWidth / 2 + 10, buttonY2, 100, buttonHeight);
                ctx.fillStyle = '#fff';
                ctx.fillText('Ch∆°i l·∫°i', centerX - buttonWidth / 2 + 60, buttonY2 + 32);
            }

            ctx.restore(); // End screen shake transform

            // Boss Health Bar (kh√¥ng b·ªã shake)
            if (game.bossActive && game.currentBoss) {
                const boss = game.currentBoss;
                const barWidth = 400;
                const barHeight = 30;
                const barX = (canvas.width - barWidth) / 2;
                const barY = 80;

                // Background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(barX - 10, barY - 10, barWidth + 20, barHeight + 30);

                // Boss name
                ctx.font = 'bold 16px Courier';
                ctx.fillStyle = '#f0f';
                ctx.textAlign = 'center';
                ctx.fillText(`üëæ BOSS LEVEL ${boss.bossLevel} üëæ`, canvas.width / 2, barY + 5);

                // Health bar background
                ctx.fillStyle = '#333';
                ctx.fillRect(barX, barY + 15, barWidth, barHeight - 10);

                // Health bar fill
                const healthPercent = boss.health / (boss.maxHealth || boss.health);
                const healthWidth = barWidth * Math.max(0, Math.min(1, healthPercent));

                // Color gradient based on health
                if (healthPercent > 0.6) ctx.fillStyle = '#0f0';
                else if (healthPercent > 0.3) ctx.fillStyle = '#ff0';
                else ctx.fillStyle = '#f00';

                ctx.fillRect(barX, barY + 15, healthWidth, barHeight - 10);

                // Health text
                ctx.font = 'bold 14px Courier';
                ctx.fillStyle = '#fff';
                const displayMaxHealth = boss.maxHealth || boss.health;
                ctx.fillText(`${Math.floor(boss.health)} / ${Math.floor(displayMaxHealth)}`, canvas.width / 2, barY + 30);
            }
        }

        function gameLoop() {
            if (!game.isPlaying) return;

            if (!game.isPaused) {
                updatePlayer();
                updateBullets();
                updateEnemies();
                updateEnemyBullets();
                updateExplosions();
                updatePowerUps();
                checkCollisions();
            }

            draw();
            requestAnimationFrame(gameLoop);
        }
    </script>
</body>

</html>